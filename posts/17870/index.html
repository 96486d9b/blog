<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Flow</title><meta name="description" content=""><meta name="keywords" content="blog,IT"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><link rel="shortcut icon" href="/blog/assets/favicon.png"><link rel="alternate" href="/blog/atom.xml" title="Flow" type="application/atom+xml"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="list.copy(): return a shallow copy of the list  最开始的时候，我想到了这样一个实例 12345678a &#x3D; [2, 3]b &#x3D; a.copy()b[0] &#x3D; 4print(a, b)print(id(a), id(b))[2, 3] [4, 3]2624807809864 2624807962184 输出结果两个是不一样的，并且两个复制之后两个的i"><meta property="og:type" content="article"><meta property="og:title" content="深浅拷贝"><meta property="og:url" content="https://antct.github.io/blog/posts/17870/index.html"><meta property="og:site_name" content="Flow"><meta property="og:description" content="list.copy(): return a shallow copy of the list  最开始的时候，我想到了这样一个实例 12345678a &#x3D; [2, 3]b &#x3D; a.copy()b[0] &#x3D; 4print(a, b)print(id(a), id(b))[2, 3] [4, 3]2624807809864 2624807962184 输出结果两个是不一样的，并且两个复制之后两个的i"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-08-05T16:00:00.000Z"><meta property="article:modified_time" content="2023-08-19T08:28:24.236Z"><meta property="article:author" content="TT"><meta property="article:tag" content="python"><meta name="twitter:card" content="summary"><script src="/blog/js/console.js"></script><link href="https://fonts.loli.net/css?family=Noto+Serif+SC" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Titillium+Web" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Roboto+Mono" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Material+Icons" rel="stylesheet"><link href="https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script><link href="https://cdn.bootcss.com/node-waves/0.7.6/waves.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/node-waves/0.7.6/waves.min.js"></script><script src="https://cdn.bootcss.com/scrollReveal.js/4.0.5/scrollreveal.min.js"></script><script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"></script><script src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><link href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script><link href="https://cdn.bootcss.com/gitalk/1.8.0/gitalk.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/gitalk/1.8.0/gitalk.min.js"></script><script src="https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script><script>
    let ROOT = "/blog/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
    let CONFIG = {
      search_service: "hexo",
      since: '2/16/2018 00:00:00',
      mathjax_cdn: 'https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML',
      poem_api: 'https://sdk.jinrishici.com/v2/browser/jinrishici.js'
    }
  </script><script src="/blog/js/search.js"></script><script src="/blog/js/app.js"></script><link rel="stylesheet" href="/blog/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>NProgress.start()</script><header class="l_header"><div class="wrapper compensate-for-scrollbar"><div class="nav-main container container--flex"> <a class="logo flat-box" href="/blog/">Flow</a><div class="menu"><ul class="h-list"><li> <a class="flat-box nav-home" href="/blog/">Home</a></li><li> <a class="flat-box nav-archives" href="/blog/archives/">Archive</a></li><li> <a class="flat-box nav-timeline" href="/blog/timeline/">Timeline</a></li><li> <a class="flat-box nav-gallery" href="/blog/gallery/">Gallery</a></li><li> <a class="flat-box nav-about" href="/blog/about/">About</a></li></ul><div class="underline"></div></div><div class="m_search"><form name="searchform" class="form u-search-form"> <input type="text" class="input u-search-input" placeholder="搜索关键词"> <i class="material-icons flat-box">search</i></form></div><ul class="switcher h-list"><li class="s-search"> <a href="javascript:void(0)"><i class="material-icons flat-box">search</i></a></li><li class="s-menu"> <a href="javascript:void(0)"><i class="material-icons flat-box">menu</i></a></li></ul></div><div class="nav-sub container container--flex"> <a class="logo" class="flat-box" href="javascript:void(0)">Flow</a><ul class="switcher h-list"><li class="s-down"> <a href="javascript:void(0)"><i class="material-icons flat-box">arrow_downward</i></a></li><li class="s-comment"> <a href="javascript:void(0)"><i class="material-icons flat-box">comment</i></a></li><li class="s-top"> <a href="javascript:void(0)"><i class="material-icons flat-box">arrow_upward</i></a></li></ul></div></div></header><aside class="menu-phone"><nav> <a href="/blog/" class="nav-home nav">Home</a> <a href="/blog/archives/" class="nav-archives nav">Archive</a> <a href="/blog/timeline/" class="nav-timeline nav">Timeline</a> <a href="/blog/gallery/" class="nav-gallery nav">Gallery</a> <a href="/blog/about/" class="nav-about nav">About</a></nav></aside><div class="l_body"><div class="container clearfix"><div id="l_pjax" class="l_main"><article class="post reveal" itemscope itemprop="blogPost"><section class="meta"><h2 class="title"> <a href="/blog/posts/17870/">深浅拷贝</a></h2> <time>2019-08-06</time> <span id="/blog/posts/17870/" class="post-count" data-flag-title="深浅拷贝"><time>字数<span id="wordcount"></span> 阅读时长<span id="min2read"></span></time></span><script>initCount("&#34;\nlist.copy(): return a shallow copy of the list\n\n最开始的时候，我想到了这样一个实例\n12345678a = [2, 3]b = a.copy()b[0] = 4print(a, b)print(id(a), id(b))[2, 3] [4, 3]2624807809864 2624807962184\n输出结果两个是不一样的，并且两个复制之后两个的id值也是不一样的，然后我就脑子习惯性地认为了，是deep copy，问题出现在哪？\n我们从头开始。我们从包含子对象的列表开始。\n1234567891011a = [[1, 2], [3, 4]]b = aprint(id(a)==id(b))b = copy.copy(a)print(id(a)==id(b))b = copy.deepcopy(a)print(id(a)==id(b))TrueFalseFalse\n输出的结果显得有一些奇怪，为什么无论是shallow copy还是deep copy，两个list对象的id值都是不同的呢？追根溯源，我们需要考虑深浅copy的定义层次。shallow copy还是deep copy，区别在于在我们新建这个对象的时候，对象是否只是复制了引用，还是重新生成了一个新的。我们来解释一下上面这个例子，为什么无论是shallow copy还是deep copy，a和b两个list对象的id值都是不同的？shallow copy不应该是一样的吗？原因是在于我们的判断层次出了问题，我们判断shallow copy还是deep copy，并不是依据list对象，而是根据list里面的子对象而言的。我们针对上面的例子继续深入下去。\n123456789101112a = [[1, 2], [3, 4]]b = copy.copy(a)print(id(a)==id(b))print(id(a[1])==id(b[1]))b = copy.deepcopy(b)print(id(a)==id(b))print(id(a[1])==id(b[1]))FalseTrueFalseFalse\n可以发现，虽然从a, b这两个list对象的角度看，即第一个和第三个都是False，似乎没有什么不同。但是从子元素a[1], b[1]看，它们的id值在shallow copy中是相同的，在deep copy中确实不同的。\n似乎有了一些些更近的理解，但是你仔细一想，还是会觉得很奇怪。我们之前的角度是，我们的判断层次是具体的对象，对于一个大的对象，我们是要判断它内部的子对象是不是一样的，依次来判断是深还是浅复制。依照这个想法，上面第二个例子，还可以更深入。\n12345a = [[1, 2], [3, 4]]b = copy.copy(a)print(id(a[1][1])==id(b[1][1]))b = copy.deepcopy(b)print(id(a[1][1])==id(b[1][1]))\n按照我们之前的逻辑，deep copy和shallow copy的区别，它到了子对象这个层次，一个是重新生成了，一个只是复制引用，那么上述例子的两个输出，应该第一个是True，第二个是False。然而呢？实际的输出结果是两个都是True，矛盾又出现了。按道理来说，a指向的1，和b指向的1，如果是shallow copy，应该是同一个。如果是deep copy，两个1应该是不同的对象，但是结果表明两个1是同一个对象。\n这涉及到了python的内存模型，它做了这样的优化，对于一些简单的对象，采用了重用对象的方法。（因为简单的对象使用的频率可能比较高）\n12345678910a = 2b = 2print(id(a)==id(b))a = 200000000b = 200000000print(id(a)==id(b))TrueFalse\n似乎问题的出现，就是因为python对于这样的简单对象做了优化，我们如果把对象变得复杂一点，就可以避免重用了，对象的id值就不一样了。于是我们可以再做一个实验。\n12345a = [[1, 2], [2000000, 4]]b = copy.copy(a)print(id(a[1][1])==id(b[1][1]))b = copy.deepcopy(b)print(id(a[1][1])==id(b[1][1]))\n按照我们的讨论，这样的输出结果应该是True和False，然而实际的输出结果确是两个都是True。为什么呢，这次是copy函数做了优化，copy对于一些无法修改的值，比如常量，字符串，元组等，在copy的过程当中，没有采取显式的复制，而是直接引用了。（因为无法修改的对象只会有读取的操作，所以无所谓要不要复制了）\n所以，简单来说，如何判断一个复制是shallow copy还是deep copy。\n\n判断的层次，我们需要判断copy一个对象的时候，我们需要干一件分解的事，从子对象角度去判断是否是产生了新的对象，还是只是复制了引用。\n我们判断子对象的时候，对于无法修改的元素，比如常量，字符串，元组等，它们不会被复制，我们需要避免这些元素对于我们判断的干扰。\n\n\n顺便穿插一下相等的判断，之前我们一直都是用&amp;#x3D;&amp;#x3D;去判断是否相等。Python中实际上还有is。\n\nis 比较的是两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同。\n\n&amp;#x3D;&amp;#x3D; 比较的是两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。默认会调用对象的__eq__()方法。\n\n\n123456789a = 20000b = 20000print(id(a), id(b))print(a is b)print(a == b)2832764370256 2832764370224FalseTrue\n简而言之，is比较的就是id值是不是一样，因为id值是内存地址的表征，而&amp;#x3D;&amp;#x3D;号判断的是值，内容是否相同。\n123456789a = 200b = 200print(id(a), id(b))print(a is b)print(a == b)1850574112 1850574112TrueTrue\n而上面这种特殊情况的出现，其实之前也解释过了，就是小整数池的存在造成的。\n&#34;")</script><div class="categories"> <a href="/blog/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><br></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><blockquote><p>list.copy(): return a shallow copy of the list</p></blockquote><p>最开始的时候，我想到了这样一个实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a.copy()</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>] [<span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">2624807809864</span> <span class="number">2624807962184</span></span><br></pre></td></tr></table></figure><p>输出结果两个是不一样的，并且两个复制之后两个的id值也是不一样的，然后我就脑子习惯性地认为了，是deep copy，问题出现在哪？</p><p>我们从头开始。<br>我们从包含子对象的列表开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>输出的结果显得有一些奇怪，为什么无论是shallow copy还是deep copy，两个list对象的id值都是不同的呢？<br>追根溯源，我们需要考虑深浅copy的定义层次。<br>shallow copy还是deep copy，区别在于在我们新建这个对象的时候，对象是否只是复制了引用，还是重新生成了一个新的。<br>我们来解释一下上面这个例子，为什么无论是shallow copy还是deep copy，a和b两个list对象的id值都是不同的？shallow copy不应该是一样的吗？原因是在于我们的判断层次出了问题，我们判断shallow copy还是deep copy，并不是依据list对象，而是根据list里面的子对象而言的。<br>我们针对上面的例子继续深入下去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a[<span class="number">1</span>])==<span class="built_in">id</span>(b[<span class="number">1</span>]))</span><br><span class="line">b = copy.deepcopy(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a[<span class="number">1</span>])==<span class="built_in">id</span>(b[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>可以发现，虽然从a, b这两个list对象的角度看，即第一个和第三个都是False，似乎没有什么不同。<br>但是从子元素a[1], b[1]看，它们的id值在shallow copy中是相同的，在deep copy中确实不同的。</p><p>似乎有了一些些更近的理解，但是你仔细一想，还是会觉得很奇怪。<br>我们之前的角度是，我们的判断层次是具体的对象，对于一个大的对象，我们是要判断它内部的子对象是不是一样的，依次来判断是深还是浅复制。依照这个想法，上面第二个例子，还可以更深入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a[<span class="number">1</span>][<span class="number">1</span>])==<span class="built_in">id</span>(b[<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line">b = copy.deepcopy(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a[<span class="number">1</span>][<span class="number">1</span>])==<span class="built_in">id</span>(b[<span class="number">1</span>][<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>按照我们之前的逻辑，deep copy和shallow copy的区别，它到了子对象这个层次，一个是重新生成了，一个只是复制引用，那么上述例子的两个输出，应该第一个是True，第二个是False。然而呢？实际的输出结果是两个都是True，矛盾又出现了。<br>按道理来说，a指向的1，和b指向的1，如果是shallow copy，应该是同一个。如果是deep copy，两个1应该是不同的对象，但是结果表明两个1是同一个对象。</p><p>这涉及到了python的内存模型，它做了这样的优化，对于一些简单的对象，采用了重用对象的方法。（因为简单的对象使用的频率可能比较高）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">a = <span class="number">200000000</span></span><br><span class="line">b = <span class="number">200000000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>似乎问题的出现，就是因为python对于这样的简单对象做了优化，我们如果把对象变得复杂一点，就可以避免重用了，对象的id值就不一样了。于是我们可以再做一个实验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2000000</span>, <span class="number">4</span>]]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a[<span class="number">1</span>][<span class="number">1</span>])==<span class="built_in">id</span>(b[<span class="number">1</span>][<span class="number">1</span>]))</span><br><span class="line">b = copy.deepcopy(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a[<span class="number">1</span>][<span class="number">1</span>])==<span class="built_in">id</span>(b[<span class="number">1</span>][<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>按照我们的讨论，这样的输出结果应该是True和False，然而实际的输出结果确是两个都是True。<br>为什么呢，这次是copy函数做了优化，copy对于一些无法修改的值，比如常量，字符串，元组等，在copy的过程当中，没有采取显式的复制，而是直接引用了。（因为无法修改的对象只会有读取的操作，所以无所谓要不要复制了）</p><p>所以，简单来说，如何判断一个复制是shallow copy还是deep copy。</p><ol><li>判断的层次，我们需要判断copy一个对象的时候，我们需要干一件分解的事，从子对象角度去判断是否是产生了新的对象，还是只是复制了引用。</li><li>我们判断子对象的时候，对于无法修改的元素，比如常量，字符串，元组等，它们不会被复制，我们需要避免这些元素对于我们判断的干扰。</li></ol><hr><p>顺便穿插一下相等的判断，之前我们一直都是用&#x3D;&#x3D;去判断是否相等。Python中实际上还有is。</p><ul><li><p>is 比较的是两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同。</p></li><li><p>&#x3D;&#x3D; 比较的是两个对象的内容是否相等，即<strong>内存地址</strong>可以不一样，内容一样就可以了。默认会调用对象的__eq__()方法。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20000</span></span><br><span class="line">b = <span class="number">20000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"></span><br><span class="line"><span class="number">2832764370256</span> <span class="number">2832764370224</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>简而言之，is比较的就是id值是不是一样，因为id值是内存地址的表征，而&#x3D;&#x3D;号判断的是值，内容是否相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">200</span></span><br><span class="line">b = <span class="number">200</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"></span><br><span class="line"><span class="number">1850574112</span> <span class="number">1850574112</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>而上面这种特殊情况的出现，其实之前也解释过了，就是小整数池的存在造成的。</p></div><div class="article-tags tags"> <a href="/blog/tags/python/">python</a></div><div class="art-item-footer"> <span class="art-item-left"><a href="/blog/posts/51808/" rel="prev" title="python的多继承机制">python的多继承机制</a></span> <span class="art-item-right"><a href="/blog/posts/25387/" rel="next" title="Her">Her</a></span></div></section></article><article class="post post-comment reveal" itemscope itemprop="blogPost"><div id="gitalk-container"></div><script type="text/javascript">var gitalk=new Gitalk({clientID:"f1cfc87bb2440fa99fd6",clientSecret:"0776c8e25fb56512ca97b038d7de075163aad978",id:window.location.pathname,repo:"blog",owner:"antct",admin:"antct",distractionFreeMode:!1,language:"zh"});gitalk.render("gitalk-container")</script></article><script>window.subData={title:"深浅拷贝",tools:!0}</script></div><aside class="l_side"><section class="m_widget about"> <img class="avatar waves-image" src="/blog/assets/avatar.jpg"><div class="header">TT</div><div id="motto-div" class="content"><div class="desc"> <span id="motto" style="white-space:pre-wrap">睁着一只眼睛，关注人生。 闭着一只眼睛，放进梦意。</span></div></div></section><section class="m_widget tagcloud"><div class="header">标签</div><div class="content"> <a href="/blog/tags/python/" style="font-size:20px;color:#000">python</a> <a href="/blog/tags/%E4%B8%89%E8%81%94%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A/" style="font-size:16px;color:grey">三联生活周刊</a> <a href="/blog/tags/%E5%8D%9A%E5%AE%A2/" style="font-size:16px;color:grey">博客</a> <a href="/blog/tags/%E5%8F%B0%E8%AF%8D/" style="font-size:16px;color:grey">台词</a> <a href="/blog/tags/%E5%9B%9E%E5%BF%86/" style="font-size:16px;color:grey">回忆</a> <a href="/blog/tags/%E5%A4%A7%E5%B8%88/" style="font-size:16px;color:grey">大师</a> <a href="/blog/tags/%E6%84%9F%E8%B0%A2/" style="font-size:16px;color:grey">感谢</a> <a href="/blog/tags/%E6%91%98%E5%BD%95/" style="font-size:16px;color:grey">摘录</a> <a href="/blog/tags/%E6%9B%B4%E6%96%B0/" style="font-size:16px;color:grey">更新</a> <a href="/blog/tags/%E6%9D%82%E8%AE%B0/" style="font-size:16px;color:grey">杂记</a> <a href="/blog/tags/%E6%9E%97%E8%AF%AD%E5%A0%82/" style="font-size:16px;color:grey">林语堂</a> <a href="/blog/tags/%E6%9E%B6%E6%9E%84/" style="font-size:16px;color:grey">架构</a> <a href="/blog/tags/%E6%B0%91%E5%9B%BD/" style="font-size:16px;color:grey">民国</a> <a href="/blog/tags/%E7%94%9F%E6%B4%BB/" style="font-size:20px;color:#000">生活</a> <a href="/blog/tags/%E7%94%B5%E5%BD%B1/" style="font-size:16px;color:grey">电影</a> <a href="/blog/tags/%E8%AF%BB%E4%B9%A6/" style="font-size:16px;color:grey">读书</a></div></section><section class="m_widget categories"><div class="header">归档</div><div class="content"><ul class="entry"><li><a class="flat-box" href="/blog/categories/%E4%B8%80%E9%9A%85/"><div class="name"> 一隅</div><div class="badget"> 1</div></a></li><li><a class="flat-box" href="/blog/categories/%E5%81%B6%E5%BE%97/"><div class="name"> 偶得</div><div class="badget"> 2</div></a></li><li><a class="flat-box" href="/blog/categories/%E6%8A%80%E6%9C%AF/"><div class="name"> 技术</div><div class="badget"> 3</div></a></li><li><a class="flat-box" href="/blog/categories/%E7%94%9F%E6%B4%BB/"><div class="name"> 生活</div><div class="badget"> 3</div></a></li></ul></div></section><section class="m_widget earth"><div class="header">客从何处来</div><div class="content"><script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=WO6qFSpsrUWuFJ2ZBizckVeLyIIjbxHz9H8qGUvzUVY"></script></div></section></aside></div></div><footer id="footer" class="clearfix"><div> 站点已运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></div></footer><div class="evanyou compensate-for-scrollbar"><canvas id="evanyou"></canvas></div><div id="aplayer-fixed"></div><script src="/blog/js/pjax.js"></script><script>NProgress.done()</script></body></html>