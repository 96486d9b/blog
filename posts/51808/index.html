<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Flow</title><meta name="description" content=""><meta name="keywords" content="blog,IT"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><link rel="shortcut icon" href="/blog/assets/favicon.png"><link rel="alternate" href="/blog/atom.xml" title="Flow" type="application/atom+xml"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="一些时候可能涉及到多继承模式，这里做一个梳理。一般的逻辑是这样的。一个简单的多继承形式。  如果我们有一个方法F，A和B中都有这个方法，当我们在类C中调用F的时候，我们如何判断这个F来自哪里？ 这里就产生了一个二义性的问题，C中的F，可能是A中的，也可能是B中的。C++中是如何处理这个问题的，C++中借助了虚基类的方法。 Python是如何处理的，干脆，我们就直接定义一个寻找方法的顺序，比如我们就"><meta property="og:type" content="article"><meta property="og:title" content="python的多继承机制"><meta property="og:url" content="https://antct.github.io/blog/posts/51808/index.html"><meta property="og:site_name" content="Flow"><meta property="og:description" content="一些时候可能涉及到多继承模式，这里做一个梳理。一般的逻辑是这样的。一个简单的多继承形式。  如果我们有一个方法F，A和B中都有这个方法，当我们在类C中调用F的时候，我们如何判断这个F来自哪里？ 这里就产生了一个二义性的问题，C中的F，可能是A中的，也可能是B中的。C++中是如何处理这个问题的，C++中借助了虚基类的方法。 Python是如何处理的，干脆，我们就直接定义一个寻找方法的顺序，比如我们就"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://antct.github.io/blog/assets/image/4.png"><meta property="og:image" content="https://antct.github.io/blog/assets/image/5.png"><meta property="og:image" content="https://antct.github.io/blog/assets/image/6.png"><meta property="og:image" content="https://antct.github.io/blog/assets/image/7.png"><meta property="og:image" content="https://antct.github.io/blog/assets/image/8.png"><meta property="article:published_time" content="2019-08-05T16:00:00.000Z"><meta property="article:modified_time" content="2023-08-19T08:28:24.236Z"><meta property="article:author" content="TT"><meta property="article:tag" content="python"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://antct.github.io/blog/assets/image/4.png"><script src="/blog/js/console.js"></script><link href="https://fonts.loli.net/css?family=Noto+Serif+SC" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Titillium+Web" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Roboto+Mono" rel="stylesheet"><link href="https://fonts.loli.net/css?family=Material+Icons" rel="stylesheet"><link href="https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script><link href="https://cdn.bootcss.com/node-waves/0.7.6/waves.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/node-waves/0.7.6/waves.min.js"></script><script src="https://cdn.bootcss.com/scrollReveal.js/4.0.5/scrollreveal.min.js"></script><script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"></script><script src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><link href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script><link href="https://cdn.bootcss.com/gitalk/1.8.0/gitalk.min.css" rel="stylesheet"><script src="https://cdn.bootcss.com/gitalk/1.8.0/gitalk.min.js"></script><script src="https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script><script>
    let ROOT = "/blog/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
    let CONFIG = {
      search_service: "hexo",
      since: '2/16/2018 00:00:00',
      mathjax_cdn: 'https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML',
      poem_api: 'https://sdk.jinrishici.com/v2/browser/jinrishici.js'
    }
  </script><script src="/blog/js/search.js"></script><script src="/blog/js/app.js"></script><link rel="stylesheet" href="/blog/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>NProgress.start()</script><header class="l_header"><div class="wrapper compensate-for-scrollbar"><div class="nav-main container container--flex"> <a class="logo flat-box" href="/blog/">Flow</a><div class="menu"><ul class="h-list"><li> <a class="flat-box nav-home" href="/blog/">Home</a></li><li> <a class="flat-box nav-archives" href="/blog/archives/">Archive</a></li><li> <a class="flat-box nav-timeline" href="/blog/timeline/">Timeline</a></li><li> <a class="flat-box nav-gallery" href="/blog/gallery/">Gallery</a></li><li> <a class="flat-box nav-about" href="/blog/about/">About</a></li></ul><div class="underline"></div></div><div class="m_search"><form name="searchform" class="form u-search-form"> <input type="text" class="input u-search-input" placeholder="搜索关键词"> <i class="material-icons flat-box">search</i></form></div><ul class="switcher h-list"><li class="s-search"> <a href="javascript:void(0)"><i class="material-icons flat-box">search</i></a></li><li class="s-menu"> <a href="javascript:void(0)"><i class="material-icons flat-box">menu</i></a></li></ul></div><div class="nav-sub container container--flex"> <a class="logo" class="flat-box" href="javascript:void(0)">Flow</a><ul class="switcher h-list"><li class="s-down"> <a href="javascript:void(0)"><i class="material-icons flat-box">arrow_downward</i></a></li><li class="s-comment"> <a href="javascript:void(0)"><i class="material-icons flat-box">comment</i></a></li><li class="s-top"> <a href="javascript:void(0)"><i class="material-icons flat-box">arrow_upward</i></a></li></ul></div></div></header><aside class="menu-phone"><nav> <a href="/blog/" class="nav-home nav">Home</a> <a href="/blog/archives/" class="nav-archives nav">Archive</a> <a href="/blog/timeline/" class="nav-timeline nav">Timeline</a> <a href="/blog/gallery/" class="nav-gallery nav">Gallery</a> <a href="/blog/about/" class="nav-about nav">About</a></nav></aside><div class="l_body"><div class="container clearfix"><div id="l_pjax" class="l_main"><article class="post reveal" itemscope itemprop="blogPost"><section class="meta"><h2 class="title"> <a href="/blog/posts/51808/">python的多继承机制</a></h2> <time>2019-08-06</time> <span id="/blog/posts/51808/" class="post-count" data-flag-title="python的多继承机制"><time>字数<span id="wordcount"></span> 阅读时长<span id="min2read"></span></time></span><script>initCount("&#34;一些时候可能涉及到多继承模式，这里做一个梳理。一般的逻辑是这样的。一个简单的多继承形式。\n\n如果我们有一个方法F，A和B中都有这个方法，当我们在类C中调用F的时候，我们如何判断这个F来自哪里？\n这里就产生了一个二义性的问题，C中的F，可能是A中的，也可能是B中的。C++中是如何处理这个问题的，C++中借助了虚基类的方法。\nPython是如何处理的，干脆，我们就直接定义一个寻找方法的顺序，比如我们就规定当寻找C中的F的时候，先去A中寻找，再去B中寻找。也就是我们的路径是CAB。（图从右向左读）但是如果我们想要一个形如CBA的路径该怎么办，只需要将上述关于类C的定义改写成class C(B, A)即可了。\n实际上这个路径就是MRO，Method Resolution Order，即方法解析顺序。形象一点说，就是当我们需要寻求某个属性，某个方法的时候，MRO就是我们的地图，我们按照MRO给我们提供的路径一直找，直到找到为止。\n这样似乎就解决了二义性的问题，但是我们又遇到了麻烦，如何去确定这个寻找的路径呢？即如何确定MRO呢？\n遍历图的方法，无非是BFS和DFS。\n早期的Python解析的时候采取了DFS的顺序。但是使用DFS会遭遇这样的问题。\n下图模式是多继承模式当中的棱形继承模式。\n\n对于上述的情况，如果采取DFS的解析顺序，那应该是DBAC。\n假设我们的A中有一个方法F，C中关于这个F进行了overwrite，B没有关于这个F的定义，那么当我们从D类调用F的时候，按照继承逻辑，我们应该调用的是C中重写之后的F。\n可事实是，我们按照我们的MRO去寻找，D向下寻找到B，没有F，再向下，因为A中始终会有F的定义。所以我们就把A中的F，认为是我们D最近的一个父类的F。C中的F相当于被屏蔽了。\n这种问题，称为继承无效。\n那采用BFS呢?\n下图模式是多继承模式当中的正常继承模式。\n\n按照BFS的解析顺序，应该是ECDAB。\n假设我们A中有一个F，C继承了A，当C调用F的时候，应该调用的实际是A中的F。但是我们按照BFS生成的MRO去寻找，如果恰巧D中有一个F，我们就会误以为是最近父类的F，实际调用的是D中的F。\n这种问题，称为单调性问题，因为CD本无联系。\n我们思考一下两个问题产生的根源是什么？\n对于单调性问题，就是因为我们去按照一个不存在的关系去寻找了。如何解决这个问题呢，说明我们不能按照BFS那种逻辑去建立一些不存在的单调关系。意味着我们必须要按照图中确切存在的关系去寻找。\n对于无效继承的问题，问题出现在我们在访问一个子类之前，却先访问了它的父类，它的父类导致这个子类直接被屏蔽了，于是我们规定，在访问一个父类之前，我们必须要访问其所有的子类。其实这就是拓扑排序。\n规避这两个问题的算法就是C3算法。\n考虑一个极端的情况。结合了上述两种问题。\n\n我们仍然从F出发，按照拓扑排序，将F从图中去除，这时候E和D的入度相同，我们按照右边优先的原则，选择E，这时候C和D的入度相同，我们按照右边优先的原则，选择C，然后再选择D。这时候只剩下入度相同的B和A，我们按照右边优先的原则，选择B，再选择A。所以整体的顺序就是FECDBA。上述两个问题都得到解决。\n有了正确的MRO关系，我们就可以引入一个关键词，称之为super，super将带领着沿着MRO寻找，直到找到为止。\n那有一个例外的情况，既然有了super这个关键词，那对于像ABC这种没有父类的类，super的存在岂不是很尴尬，于是在新式类的关系，所有的类都有个基类，object，所以实际上是这样的。\n上面这段话是我瞎说的，我也不知道为啥都指向一个object。\n\n有了这些之后，我们关注多继承里的初始化问题。\n一个比较简单粗暴的方法是\n1234567891011121314151617181920212223242526class A():    def __init__(self):        pass    class B():    def __init__(self):        passclass C():    def __init__(self):        pass    class D(A, B):    def __init__(self):        A.__init__(self)        B.__init__(self)class E(B, C):    def __init__(self):        B.__init__(self)        C.__init__(self)class F(D, E):    def __init__(self):        D.__init__(self)        E.__init__(self)\n\n可是，有时候在想，既然有了super，那为啥不用super初始化呢。\n可能会有一个天真的想法，super强大到可以去寻找父类关系，我们可以用super()去替代。\n1234567891011121314151617181920212223class A():    def __init__(self):        passclass B():    def __init__(self):        passclass C():    def __init__(self):        passclass D(A, B):    def __init__(self):        super().__init__() class E(B, C):    def __init__(self):        super().__init__()class F(D, E):    def __init__(self):        super().__init__()\n\n代码显得很优雅，可是，这是不可能的。\nsuper的作用，是将带领着沿着MRO寻找，直到找到为止。也就是说，类D的初始化，super().init()指向的，实际上就是类A的__init__，B的__init__根本没有进行。\n简化一下，就是\n1234567891011121314151617class A():    def __init__(self):        print(&amp;#x27;I am A&amp;#x27;)class B():    def __init__(self):        print(&amp;#x27;I am B&amp;#x27;)class C(A, B):    def __init__(self):        super().__init__()if __name__ == &amp;#x27;__main__&amp;#x27;:    obj = C()    I am A\n\n输出只有I am A，来自类A的初始化反馈。\n那应该如何用super进行初始化呢？\n上面的例子，相当于super()在找到了A中的初始化之后就戛然而止，可是我们还需要寻找B的初始化。\n12345678910111213141516171819class A():    def __init__(self):        print(&amp;#x27;I am A&amp;#x27;)class B():    def __init__(self):        print(&amp;#x27;I am B&amp;#x27;)class C(A, B):    def __init__(self):        super().__init__()        super(A, self).__init__()if __name__ == &amp;#x27;__main__&amp;#x27;:    obj = C()    I am AI am B\n\n上面的例子也是很显而易见，既然我们之前super().init()的过程在MRO路径的A处就停止了，那么就从A处开始，跳过之前的，继续寻找后续中与当前C类有父类关系的初始化__init__函数，即B中的__init__。\n&#34;")</script><div class="categories"> <a href="/blog/categories/%E6%8A%80%E6%9C%AF/">技术</a></div><br></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>一些时候可能涉及到多继承模式，这里做一个梳理。一般的逻辑是这样的。一个简单的多继承形式。</p><p><img src="/blog/assets/image/4.png" alt="4.png"></p><p>如果我们有一个方法F，A和B中都有这个方法，当我们在类C中调用F的时候，我们如何判断这个F来自哪里？</p><p>这里就产生了一个二义性的问题，C中的F，可能是A中的，也可能是B中的。<br>C++中是如何处理这个问题的，C++中借助了虚基类的方法。</p><p>Python是如何处理的，干脆，我们就直接定义一个寻找方法的顺序，比如我们就规定当寻找C中的F的时候，先去A中寻找，再去B中寻找。也就是我们的路径是CAB。（图从右向左读）<br>但是如果我们想要一个形如CBA的路径该怎么办，只需要将上述关于类C的定义改写成class C(B, A)即可了。</p><p>实际上这个路径就是MRO，Method Resolution Order，即方法解析顺序。形象一点说，就是当我们需要寻求某个属性，某个方法的时候，MRO就是我们的地图，我们按照MRO给我们提供的路径一直找，直到找到为止。</p><p>这样似乎就解决了二义性的问题，但是我们又遇到了麻烦，如何去确定这个寻找的路径呢？即如何确定MRO呢？</p><p>遍历图的方法，无非是BFS和DFS。</p><p>早期的Python解析的时候采取了DFS的顺序。但是使用DFS会遭遇这样的问题。</p><p>下图模式是多继承模式当中的棱形继承模式。</p><p><img src="/blog/assets/image/5.png" alt="5.png"></p><p>对于上述的情况，如果采取DFS的解析顺序，那应该是DBAC。</p><p>假设我们的A中有一个方法F，C中关于这个F进行了overwrite，B没有关于这个F的定义，那么当我们从D类调用F的时候，按照继承逻辑，我们应该调用的是C中重写之后的F。</p><p>可事实是，我们按照我们的MRO去寻找，D向下寻找到B，没有F，再向下，因为A中始终会有F的定义。所以我们就把A中的F，认为是我们D最近的一个父类的F。C中的F相当于被屏蔽了。</p><p>这种问题，称为继承无效。</p><p>那采用BFS呢?</p><p>下图模式是多继承模式当中的正常继承模式。</p><p><img src="/blog/assets/image/6.png" alt="6.png"></p><p>按照BFS的解析顺序，应该是ECDAB。</p><p>假设我们A中有一个F，C继承了A，当C调用F的时候，应该调用的实际是A中的F。但是我们按照BFS生成的MRO去寻找，如果恰巧D中有一个F，我们就会误以为是最近父类的F，实际调用的是D中的F。</p><p>这种问题，称为单调性问题，因为CD本无联系。</p><p>我们思考一下两个问题产生的根源是什么？</p><p>对于单调性问题，就是因为我们去按照一个不存在的关系去寻找了。如何解决这个问题呢，说明我们不能按照BFS那种逻辑去建立一些不存在的单调关系。意味着我们必须要按照图中确切存在的关系去寻找。</p><p>对于无效继承的问题，问题出现在我们在访问一个子类之前，却先访问了它的父类，它的父类导致这个子类直接被屏蔽了，于是我们规定，在访问一个父类之前，我们必须要访问其所有的子类。其实这就是拓扑排序。</p><p>规避这两个问题的算法就是C3算法。</p><p>考虑一个极端的情况。结合了上述两种问题。</p><p><img src="/blog/assets/image/7.png" alt="7.png"></p><p>我们仍然从F出发，按照拓扑排序，将F从图中去除，这时候E和D的入度相同，我们按照右边优先的原则，选择E，这时候C和D的入度相同，我们按照右边优先的原则，选择C，然后再选择D。这时候只剩下入度相同的B和A，我们按照右边优先的原则，选择B，再选择A。所以整体的顺序就是FECDBA。上述两个问题都得到解决。</p><p>有了正确的MRO关系，我们就可以引入一个关键词，称之为super，super将带领着沿着MRO寻找，直到找到为止。</p><p>那有一个例外的情况，既然有了super这个关键词，那对于像ABC这种没有父类的类，super的存在岂不是很尴尬，于是在新式类的关系，所有的类都有个基类，object，所以实际上是这样的。</p><p>上面这段话是我瞎说的，我也不知道为啥都指向一个object。</p><p><img src="/blog/assets/image/8.png" alt="8.png"></p><p>有了这些之后，我们关注多继承里的初始化问题。</p><p>一个比较简单粗暴的方法是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        B.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>(D, E):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        D.__init__(self)</span><br><span class="line">        E.__init__(self)</span><br></pre></td></tr></table></figure><p>可是，有时候在想，既然有了super，那为啥不用super初始化呢。</p><p>可能会有一个天真的想法，super强大到可以去寻找父类关系，我们可以用super()去替代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__() </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>(D, E):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br></pre></td></tr></table></figure><p>代码显得很优雅，可是，这是不可能的。</p><p>super的作用，是将带领着沿着MRO寻找，直到找到为止。也就是说，类D的初始化，super().<strong>init</strong>()指向的，实际上就是类A的__init__，B的__init__根本没有进行。</p><p>简化一下，就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    obj = C()</span><br><span class="line">    </span><br><span class="line">I am A</span><br></pre></td></tr></table></figure><p>输出只有I am A，来自类A的初始化反馈。</p><p>那应该如何用super进行初始化呢？</p><p>上面的例子，相当于super()在找到了A中的初始化之后就戛然而止，可是我们还需要寻找B的初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">super</span>(A, self).__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    obj = C()</span><br><span class="line">    </span><br><span class="line">I am A</span><br><span class="line">I am B</span><br></pre></td></tr></table></figure><p>上面的例子也是很显而易见，既然我们之前super().<strong>init</strong>()的过程在MRO路径的A处就停止了，那么就从A处开始，跳过之前的，继续寻找后续中与当前C类有父类关系的初始化__init__函数，即B中的__init__。</p></div><div class="article-tags tags"> <a href="/blog/tags/python/">python</a></div><div class="art-item-footer"> <span class="art-item-right"><a href="/blog/posts/17870/" rel="next" title="深浅拷贝">深浅拷贝</a></span></div></section></article><article class="post post-comment reveal" itemscope itemprop="blogPost"><div id="gitalk-container"></div><script type="text/javascript">var gitalk=new Gitalk({clientID:"f1cfc87bb2440fa99fd6",clientSecret:"0776c8e25fb56512ca97b038d7de075163aad978",id:window.location.pathname,repo:"blog",owner:"antct",admin:"antct",distractionFreeMode:!1,language:"zh"});gitalk.render("gitalk-container")</script></article><script>window.subData={title:"python的多继承机制",tools:!0}</script></div><aside class="l_side"><section class="m_widget about"> <img class="avatar waves-image" src="/blog/assets/avatar.jpg"><div class="header">TT</div><div id="motto-div" class="content"><div class="desc"> <span id="motto" style="white-space:pre-wrap">睁着一只眼睛，关注人生。 闭着一只眼睛，放进梦意。</span></div></div></section><section class="m_widget tagcloud"><div class="header">标签</div><div class="content"> <a href="/blog/tags/python/" style="font-size:20px;color:#000">python</a> <a href="/blog/tags/%E4%B8%89%E8%81%94%E7%94%9F%E6%B4%BB%E5%91%A8%E5%88%8A/" style="font-size:16px;color:grey">三联生活周刊</a> <a href="/blog/tags/%E5%8D%9A%E5%AE%A2/" style="font-size:16px;color:grey">博客</a> <a href="/blog/tags/%E5%8F%B0%E8%AF%8D/" style="font-size:16px;color:grey">台词</a> <a href="/blog/tags/%E5%9B%9E%E5%BF%86/" style="font-size:16px;color:grey">回忆</a> <a href="/blog/tags/%E5%A4%A7%E5%B8%88/" style="font-size:16px;color:grey">大师</a> <a href="/blog/tags/%E6%84%9F%E8%B0%A2/" style="font-size:16px;color:grey">感谢</a> <a href="/blog/tags/%E6%91%98%E5%BD%95/" style="font-size:16px;color:grey">摘录</a> <a href="/blog/tags/%E6%9B%B4%E6%96%B0/" style="font-size:16px;color:grey">更新</a> <a href="/blog/tags/%E6%9D%82%E8%AE%B0/" style="font-size:16px;color:grey">杂记</a> <a href="/blog/tags/%E6%9E%97%E8%AF%AD%E5%A0%82/" style="font-size:16px;color:grey">林语堂</a> <a href="/blog/tags/%E6%9E%B6%E6%9E%84/" style="font-size:16px;color:grey">架构</a> <a href="/blog/tags/%E6%B0%91%E5%9B%BD/" style="font-size:16px;color:grey">民国</a> <a href="/blog/tags/%E7%94%9F%E6%B4%BB/" style="font-size:20px;color:#000">生活</a> <a href="/blog/tags/%E7%94%B5%E5%BD%B1/" style="font-size:16px;color:grey">电影</a> <a href="/blog/tags/%E8%AF%BB%E4%B9%A6/" style="font-size:16px;color:grey">读书</a></div></section><section class="m_widget categories"><div class="header">归档</div><div class="content"><ul class="entry"><li><a class="flat-box" href="/blog/categories/%E4%B8%80%E9%9A%85/"><div class="name"> 一隅</div><div class="badget"> 1</div></a></li><li><a class="flat-box" href="/blog/categories/%E5%81%B6%E5%BE%97/"><div class="name"> 偶得</div><div class="badget"> 2</div></a></li><li><a class="flat-box" href="/blog/categories/%E6%8A%80%E6%9C%AF/"><div class="name"> 技术</div><div class="badget"> 3</div></a></li><li><a class="flat-box" href="/blog/categories/%E7%94%9F%E6%B4%BB/"><div class="name"> 生活</div><div class="badget"> 3</div></a></li></ul></div></section><section class="m_widget earth"><div class="header">客从何处来</div><div class="content"><script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=WO6qFSpsrUWuFJ2ZBizckVeLyIIjbxHz9H8qGUvzUVY"></script></div></section></aside></div></div><footer id="footer" class="clearfix"><div> 站点已运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></div></footer><div class="evanyou compensate-for-scrollbar"><canvas id="evanyou"></canvas></div><div id="aplayer-fixed"></div><script src="/blog/js/pjax.js"></script><script>NProgress.done()</script></body></html>